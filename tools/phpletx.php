<?php

namespace letx;

$html = <<<EOT
  <html>
   <head>
    <title>Test Page</title>
     <meta http-equiv = "Content-Type" content = "text/html; charset=utf-8">
   </head>
   <body>
    <h2>Welcome!</h2>
     <p>This page was generated by KSWEB web package!</p >
     <p>We have a website: <a href = ' '>http://www.kslabs.ru/</ a></p >
      <br /><p><a href = 'index.php?viewInfo=1'>Click</ a> to view PHP info.</p >
      <br /><p><a href = 'index.php?viewInfo=2'>Click</ a> to run PHP code.</p >
   </body>
  </html>
EOT;

assert_options(ASSERT_ACTIVE, 1);
assert_options(ASSERT_WARNING, 0);
assert_options(ASSERT_QUIET_EVAL, 1);
function assert_handler($file, $line, $code, $msg) {
    $str = <<<EOT
<hr/>Assertion Failed: <br />
File '$file'<br />
Line '$line'<br />
Msg  '$msg'<br /><hr />
EOT;
    echo $msg;
}
assert_options(ASSERT_CALLBACK, 'assert_handler');

$viewInfo = $_GET['viewInfo'];
if ($viewInfo == '1') {
    phpinfo();
} elseif ($viewInfo == '2') {
    main();
} else {
    echo $html;
}


# ===============================================================
# ========================== LETX ERROR ==========================
# ===============================================================

class LetxError extends \Exception {

    public function __construct($msg) {
        parent::__construct($msg);
    }

}

class NotMatchError extends LetxError {

    public $_letx = null;
    public $index = -1;

    public function __construct($index, $msg, $obj=null) {
        parent::__construct($msg);
        $this->_letx = obj;
        $this->index = index;
    }

    public function __toString() {
        return $this->getMessage();
    }

}

class ListNotMatchError extends NotMatchError {

    public $_dict = [];
    public $_max_index = -1;
    public $_ex_map = [];

    public function __construct($index, $msg, $tag_list, $ex_list, $obj=null) {
        parent::__construct($index, $msg, $obj);
        $this->_dict = [];
        $this->_ex_map =[];

        $this->index = index;
        foreach($ex_list as $_ex) {
            if($_ex->index > $this->_max_index){
                $this->_max_index = $_ex->index;
            }
        }

        foreach($ex_list as $_idx => $_ex) {
            $k = $tag_list[$_idx];
            $this->_dict[$k] = $_ex;
            if($_ex->index == $this->_max_index) {
                $this->_ex_map[$k] = $_ex;
            }
        }
    }

    public function __toString() {
        $arr = [];
        foreach($this->_ex_map as $tag => $_ex) {
            $arr[] = "\n<{$tag}> :" . $this->getMessage();
        }
        return $this->getMessage() . ' >>>>\n ' . join('\n', $arr);
    }

}


# ===============================================================
# ========================== LETX MAIN ==========================
# ===============================================================

class _Log {

    public static $debug = false;

    public static function log($msg) {
        if(self::$debug && !empty($msg)) {
            echo $_msg;
        }
    }


    public static function fix_list($arr) {
        $idx_count = 0;
        foreach ($arr as $k => $v) {
            if ($idx_count !== $k) {
                $idx_count = -1;
                break;
            }
            $idx_count += 1;
        }

        if($idx_count >= 0) {
            return $v;
        } else {
            $vv = [];
            foreach ($arr as $k => $v) {
                $vv[] = [$k => $v];
            }
            return $vv;
        }
    }


    public static function fstr($QUOTES, $ESCAPE='\\') {
        // i[si] is " or ', return index of next i[si] without \ before it
        $QUOTES = trim($QUOTES);

        $_fstr = function($index, $s, $sl) {
            if($s[$index] != $QUOTES) {
                $msg = "fstr not start s[{$index}:]<`...{$s[$index]}...`>,`{$QUOTES}`.";
                throw new NotMatchError($index, $msg, $_fstr);
            }
            $_index = $index + 1;
            while($_index < $sl && $s[$_index] != $QUOTES) {
                $_index += $s[$_index] == $ESCAPE ? 2 : 1;
            }
            if($s[$_index] != $QUOTES) {
                $msg = "fstr not end s[{$index}:]<`...{$s[$index]}...`>,`{$QUOTES}`.";
                throw new NotMatchError($_index, $msg, $_fstr);
            }
            $_len = $_index - $index - 1;
            return [$_index + 1, substr($s, $index + 1, $_len)];
        };

        return $_fstr;
    }


    public static function ftoken($END, $PRE=null, $SKIP=null) {
        $_ftoken = function($index, $s, $sl) {
            while(!empty($PRE) && $index < $sl && in_array($s[$index], $PRE)) {
                $index += 1;
            }
            if($index >= $sl) {
                $msg = "out of str length {$sl} at {$index}.";
                throw new NotMatchError($index, $msg, $_ftoken);
            }
            if(in_array($s[$index], $END)) {
                $ss = LetxBuild::SUB($s, $index);
                $msg = "ftoken not start s[{$index}:]<`...{$ss}...`>,`{$s[$index]}`.";
                throw new NotMatchError($index, $msg, $_ftoken);
            }
            $val = [];
            while($index < $sl && !in_array($s[$index], $END)) {
                if(!empty($SKIP) && in_array($s[$index], $SKIP)) {
                } else {
                    $val[] = $s[$index];
                }
                $index += 1;
            }
            return [$index, join('', $val)];
        };

        return $_ftoken;
    }

}

class _Base extends _Log {
    public static $TestFalse = -9999;

    public function test($index, $s, $sl) {
        try {
            list($index, $val) = $this($index, $s, $sl);
            return [$index, $val];
        } catch (NotMatchError $ex){
            $str = "{$this} test NotMatchError:{$ex} @{$index}<`..." . SUB($s, $index) . "...`>";
            return [$index, self::$TestFalse];
        }
    }

    public function __invoke($index, $s, $sl) {
        assert($index < $sl, "base index:{$index} out of max_len:{$sl}.");
        return [null, $index];
    }

    public function __toString() {
        $cls = get_class($this);
        $tag = !empty($this->__tag__) ? $this->__tag__ : 'unknown';
        return "callable letx {$cls}:{$tag}";
    }

}

class LetxFunc {

    private $_letx = null;
    private $tag_in = '';

    public function __construct($tag_in, $letx) {
        $this->_letx = $letx;
        $this->tag_in = $tag_in;
    }

    public function __invoke($index, $s, $sl) {
        assert($index < $sl, "letx index:{$index} out of max_len:{$sl}.");

        $obj = $this->_letx;
        $env = $obj->env();
        assert(!empty($env[$this->tag_in]), "comp_letx _pkg_parse:empty value ({$this->tag_in}) in env.");

        list($_parse_func, $_pkg, ) = $env[$this->tag_in];
        list($index, $ret_tmp) = $_parse_func($index_in, $str_in, $str_len);
        $ret = $_pkg($ret_tmp);
        return [$index, $ret];
    }

    public function __toString() {
        return "letx {$this->tag_in}";
    }

}


class LetxBuild extends _Log {

    private static function pre_pkg($tag, $pkg_tag, $pkg_dict) {
        if(!empty(self::$PKG_MAP[$pkg_tag])) {
            $f = self::$PKG_MAP[$pkg_tag];
            return $f($tag);
        }
        if(!empty($pkg_dict[$pkg_tag])) {
            return $pkg_dict[$pkg_tag];
        }
        if(!empty($pkg_dict[$tag])) {
            return $pkg_dict[$tag];
        }
        return self::$DEFAULT_PKG;
    }

    private static function setkey($env, $key, $val=null) {
        assert(empty($env[$key]), "mutil tag in key:{$key}");
        $env[$key] = $val;
        return $env;
    }

    private static function pre_env($s, $pkg_dict, $fix='') {
        $env = [];
        if(is_array($s) && len($s) == 1) {
            $k = array_keys($s)[0];
            $v = $s[$k];
            $arr = explode('#', $k, 2);
            $k = $arr[0];
            if(self::IS_TAG($k)) {
                $pkg_tag = count($arr) == 2 ? trim($arr[1]) : '';
                $tag = substr($k, 1, -1);

                $pkg = self::pre_pkg($tag, $pkg_tag, $pkg_dict);
                $env = self::setkey($env, "#{$tag}", $pkg);

                $v = is_array($v) ? self::fix_list($v) : [$v, ];
                $env = self::setkey($env, $tag);
                foreach($v as $i => $item) {
                    $tmp = self::pre_env($item, $pkg_dict, "{$tag}#{$i}");
                    $env = array_merge($env, $tmp);
                }
                return $env;
            }
        }
        $env = self::setkey($env, $fix);
        return $env;
    }

    private static $PKG_MAP = [];
    private static $DEFAULT_PKG = null;
    private static $_null_parse = null;

    const BY_ORDER = 1;
    const MAX_INDEX = 2;

    private $mtag = '_';
    private $_env = [];
    public $base_list_mode = -1;

    public function __construct($_sdic, $mtag='_', $base_list_mode=self::BY_ORDER) {
        assert(is_array($_sdic) && !empty($_sdic['<_>']) && is_array($_sdic['<_>']), 'input must as ["<_>": [...]].');

        self::$PKG_MAP = !empty(self::$PKG_MAP) ? self::$PKG_MAP : self::build_pkg_map();
        self::$DEFAULT_PKG = !empty(self::$DEFAULT_PKG) ? self::$DEFAULT_PKG : function($x){ return $x; };

        self::$_null_parse = !empty(self::$_null_parse) ? self::$_null_parse : function($index_in, $str_in, $str_len) {
            $index = self::SKIP_SPACE($index_in, $str_in, $str_len);
            return [$index, ''];
        };

        $_tag_dict = ['<_>' => $_sdic['<_>']];
        $_func_dict = [];
        $_pkg_dict = [];
        foreach($_sdic as $k => $v) {
            if(self::IS_FUN($k)) {
                $_func_dict[$k] = $v;
            } elseif(substr($k, 0, 1) == '#') {
                $_k = substr($k, 1);
                $_pkg_dict[$_k] = $v;
            }
        }

        $this->mtag = $mtag;
        $this->_env = self::pre_env($_tag_dict, $_pkg_dict);
        $this->_parse = $this->comp_letx($_tag_dict, $_func_dict);

        $this->base_list_mode = $base_list_mode;
        assert(is_callable($this->_parse), 'comp_letx _parse must callable.');
    }

    public function env() {
        return $this->_env;
    }

    public function parse($str_in) {
        $f = $this->_parse;
        list($index, $ret) = $f(0, $str_in, strlen($str_in));
        return [$index, $ret];
    }

    public function find_tag($tag_in) {
        if(empty($tag_in)) {
            return self::$_null_parse;
        }

        $tag_in = substr($tag_in, 0, 1) == '!' ? substr($tag_in, 1) : $tag_in;
        assert(!empty($this->_env[$tag_in]), "comp_letx find_tag:can not find({$tag_in}) in env.");

        $_pkg_parse = new LetxFunc($tag_in, $this);
        return $_pkg_parse;
    }

    private function add_tag($nk, $val) {
        assert(array_key_exists($this->_env, $nk) && is_null($this->_env[$nk]), "comp_letx add_tag:mutil tag {$nk} in env.");
        $this->_env[$nk] = $val;
    }

    private function comp_tag($args, $_func_dict, $_fix_tag) {
        if(is_callable($args)) {
            return [$_fix_tag, $args];
        } elseif(is_str($args)) {
            return $this->comp_tag(['><' => $args], $_func_dict, $_fix_tag);
        } elseif(is_array($arg)) {
            assert(count($args) == 1, "comp_tag tag|func dict {$_fix_tag} must len==1.");
            $_k = array_keys($args)[0];
            $_v = $args[$_k];
            $_k = explode('#', $_k, 2)[0];
            if(self::IS_FUN($_k)) {
                assert(!empty($_func_dict[$_k]), "comp_tag func dict {$_k} must in fdic.");
                $f = $_func_dict[$_k];
                return [$_fix_tag, $f($_v, $this)];
            } elseif(self::IS_TAG($_k)) {
                $tmp_func = $this->comp_letx($args, $_func_dict);
                return [substr($_k, 1, -1), tmp_func];
            }
        } else {
            assert(false, 'comp_tag item:%s not support.');
        }
    }

    private function comp_letx($tag_dict, $func_dict) {
        assert(is_array($tag_dict) && len($tag_dict) == 1, 'comp_letx must be dict with len==1');

        $k = array_keys($tag_dict)[0];
        $v = $tag_dict[$k];
        $k = explode('#', $k, 1)[0];
        assert(self::IS_TAG($k), "comp_letx {$k} must be tag.");

        $_main_tag = substr($k, 1, -1);
        $letx_list = is_array($v) ? self::fix_list($v) : [$v, ];

        $pkg_tag = "#{$_main_tag}";
        $pkg = !empty($this->_env[$pkg_tag]) ? $this->_env[$pkg_tag] : self::$DEFAULT_PKG;
        assert(is_callable($pkg), "pkg {$_main_tag} must callable.");

        $parse_func = null;
        $tag_list = [];
        foreach($letx_list as $i => $item) {
            $fix_tag = "{$_main_tag}#{$i}";
            list($tag, $parse_func) = $this->comp_tag($item, $func_dict, $fix_tag);
            if($tag == $fix_tag) {
                $this->add_tag($tag, [$parse_func, self::DEFAULT_PKG, $item]);
            }
            $tag_list[] = $tag;
        }
        $func_obj = count($letx_list) > 1 ? new BaseList([$_main_tag, $tag_list], $this) : $parse_func;
        $this->add_tag($_main_tag, [$func_obj, $pkg, $letx_list]);
        return $_main_tag == '_' ? $this->find_tag($this->mtag) : $this->find_tag($_main_tag);
    }

}

# ===============================================================
# ========================== HELP FUNC ==========================
# ===============================================================


$sdic_json = [
    '<_>' => [
        '<str>' => [LetxBuild::fstr('"'), LetxBuild::fstr("'")],
        '<None>#N' => ["None", "null"],
        '<True>#T' => "True",
        '<False>#F' => "False",
        '<num>#0^int' => '</\d+/>',
        '<list>#[0]' => [
            '>join<' => ["[", "<_>", ",", "]"],
        ],
        '<list2>#[0]' => [
            '>join<' => ["[", "<_>", ",,", "]"],
        ],
        '<dict>#{:}' => [
            '>join<' => ["{", "<str|num|token>:<_>", ",", "}"],
        ],
        '<token>' => LetxBuild::ftoken(['{', '}', '[', ']', ':', ','], [' ', "\r", "\n", "\t"]),
    ],
    '><' => '\BaseReg',
    '>join<' => '\BaseJoin',
];

function json_load($s) {
    $obj = new LetxBuild($sdic_json);
    list($idx, $ret) = $obj->parse($s);
    return $ret;
}

function main() {
    $arr = [];
    foreach(range(1, 10) as $n){
        $arr[] = function() use ($n) {
            return $n;
        };
    }

    foreach($arr as $f) {
        echo $f() ."<br />";
    }

    $obj = new LetxBuild($sdic_json);

}